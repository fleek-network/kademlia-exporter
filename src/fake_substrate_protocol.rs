use async_std::{io, task};
use futures::future::{self, Ready};
use futures::prelude::*;
use libp2p::{
    core::{
        nodes::ListenerId,
        upgrade::Negotiated, ConnectedPoint, InboundUpgrade, Multiaddr,
        OutboundUpgrade, UpgradeInfo,
    },
    swarm::{
        IntoProtocolsHandler, KeepAlive, NetworkBehaviourAction,
        PollParameters, ProtocolsHandler, ProtocolsHandlerEvent, ProtocolsHandlerUpgrErr,
        SubstreamProtocol,
    },
    PeerId,
};
use std::{
    error::Error,
    marker::PhantomData,
    task::{Context, Poll},
};
use void::Void;

#[derive(Debug, Copy, Clone)]
pub struct FakeSubstrateConfig<TSubstream> {
    /// Marker to pin the generic.
    marker: PhantomData<TSubstream>,
}

impl<TSubstream> FakeSubstrateConfig<TSubstream>{
    pub fn new() -> FakeSubstrateConfig<TSubstream> {
        FakeSubstrateConfig{
            marker: PhantomData,
        }
    }
}

impl<TSubstream> libp2p::swarm::NetworkBehaviour for FakeSubstrateConfig<TSubstream>
where
    TSubstream: AsyncRead + AsyncWrite + Unpin,
{
    /// Handler for all the protocols the network behaviour supports.
    type ProtocolsHandler = FakeSubstrateHandler<TSubstream>;

    /// Event generated by the `NetworkBehaviour` and that the swarm will report back.
    type OutEvent = FakeSubstrateEvent;

    /// Creates a new `ProtocolsHandler` for a connection with a peer.
    ///
    /// Every time an incoming connection is opened, and every time we start dialing a node, this
    /// method is called.
    ///
    /// The returned object is a handler for that specific connection, and will be moved to a
    /// background task dedicated to that connection.
    ///
    /// The network behaviour (ie. the implementation of this trait) and the handlers it has
    /// spawned (ie. the objects returned by `new_handler`) can communicate by passing messages.
    /// Messages sent from the handler to the behaviour are injected with `inject_node_event`, and
    /// the behaviour can send a message to the handler by making `poll` return `SendEvent`.
    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        FakeSubstrateHandler {
            substreams: vec![],
            marker: PhantomData,
        }
    }

    /// Addresses that this behaviour is aware of for this specific peer, and that may allow
    /// reaching the peer.
    ///
    /// The addresses will be tried in the order returned by this function, which means that they
    /// should be ordered by decreasing likelihood of reachability. In other words, the first
    /// address should be the most likely to be reachable.
    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        vec![]
    }

    /// Indicates the behaviour that we connected to the node with the given peer id through the
    /// given endpoint.
    ///
    /// This node now has a handler (as spawned by `new_handler`) running in the background.
    fn inject_connected(&mut self, peer_id: PeerId, endpoint: ConnectedPoint) {
    }

    /// Indicates the behaviour that we disconnected from the node with the given peer id. The
    /// endpoint is the one we used to be connected to.
    ///
    /// There is no handler running anymore for this node. Any event that has been sent to it may
    /// or may not have been processed by the handler.
    fn inject_disconnected(&mut self, peer_id: &PeerId, endpoint: ConnectedPoint) {}

    /// Informs the behaviour about an event generated by the handler dedicated to the peer identified by `peer_id`.
    /// for the behaviour.
    ///
    /// The `peer_id` is guaranteed to be in a connected state. In other words, `inject_connected`
    /// has previously been called with this `PeerId`.
    fn inject_node_event(
        &mut self,
        peer_id: PeerId,
        event: <<Self::ProtocolsHandler as IntoProtocolsHandler>::Handler as ProtocolsHandler>::OutEvent,
    ) {
    }

    /// Indicates to the behaviour that we tried to reach an address, but failed.
    ///
    /// If we were trying to reach a specific node, its ID is passed as parameter. If this is the
    /// last address to attempt for the given node, then `inject_dial_failure` is called afterwards.
    fn inject_addr_reach_failure(
        &mut self,
        _peer_id: Option<&PeerId>,
        _addr: &Multiaddr,
        _error: &dyn Error,
    ) {
    }

    /// Indicates to the behaviour that we tried to dial all the addresses known for a node, but
    /// failed.
    ///
    /// The `peer_id` is guaranteed to be in a disconnected state. In other words,
    /// `inject_connected` has not been called, or `inject_disconnected` has been called since then.
    fn inject_dial_failure(&mut self, _peer_id: &PeerId) {}

    /// Indicates to the behaviour that we have started listening on a new multiaddr.
    fn inject_new_listen_addr(&mut self, _addr: &Multiaddr) {}

    /// Indicates to the behaviour that a new multiaddr we were listening on has expired,
    /// which means that we are no longer listening in it.
    fn inject_expired_listen_addr(&mut self, _addr: &Multiaddr) {}

    /// Indicates to the behaviour that we have discovered a new external address for us.
    fn inject_new_external_addr(&mut self, _addr: &Multiaddr) {}

    /// A listener experienced an error.
    fn inject_listener_error(&mut self, _id: ListenerId, _err: &(dyn std::error::Error + 'static)) {
    }

    /// A listener closed.
    fn inject_listener_closed(&mut self, _id: ListenerId) {}

    /// Polls for things that swarm should do.
    ///
    /// This API mimics the API of the `Stream` trait. The method may register the current task in
    /// order to wake it up at a later point in time.
    fn poll(&mut self, cx: &mut Context, params: &mut impl PollParameters)
        -> Poll<NetworkBehaviourAction<<<Self::ProtocolsHandler as IntoProtocolsHandler>::Handler as ProtocolsHandler>::InEvent, Self::OutEvent>>
    {
        Poll::Pending
    }
}

pub struct FakeSubstrateHandler<TSubstream> {
    substreams: Vec<Negotiated<TSubstream>>,
    /// Marker to pin the generic.
    marker: PhantomData<TSubstream>,
}

impl<TSubstream> ProtocolsHandler for FakeSubstrateHandler<TSubstream>
where
    TSubstream: AsyncRead + AsyncWrite + Unpin,
{
    type InEvent = Void;
    type OutEvent = Void;
    type Error = Void;
    type Substream = TSubstream;
    type InboundProtocol = FakeSubstrateProtocolConfig;
    type OutboundProtocol = FakeSubstrateProtocolConfig;
    type OutboundOpenInfo = Void;

    #[inline]
    fn listen_protocol(&self) -> SubstreamProtocol<Self::InboundProtocol> {
        SubstreamProtocol::new(FakeSubstrateProtocolConfig {})
    }

    #[inline]
    fn inject_fully_negotiated_inbound(
        &mut self,
        protocol: <Self::InboundProtocol as InboundUpgrade<TSubstream>>::Output,
    ) {
        self.substreams.push(protocol)
    }

    #[inline]
    fn inject_fully_negotiated_outbound(
        &mut self,
        protocol: <Self::OutboundProtocol as OutboundUpgrade<TSubstream>>::Output,
        _: Self::OutboundOpenInfo,
    ) {
        self.substreams.push(protocol)
    }

    #[inline]
    fn inject_event(&mut self, _: Self::InEvent) {
    }

    #[inline]
    fn inject_dial_upgrade_error(
        &mut self,
        _: Self::OutboundOpenInfo,
        _: ProtocolsHandlerUpgrErr<
            <Self::OutboundProtocol as OutboundUpgrade<Self::Substream>>::Error,
        >,
    ) {
    }

    #[inline]
    fn connection_keep_alive(&self) -> KeepAlive {
        KeepAlive::Yes
    }

    #[inline]
    fn poll(
        &mut self,
        _: &mut Context,
    ) -> Poll<
        ProtocolsHandlerEvent<
            Self::OutboundProtocol,
            Self::OutboundOpenInfo,
            Self::OutEvent,
            Self::Error,
        >,
    > {
        Poll::Pending
    }
}

pub enum FakeSubstrateEvent {}

pub struct FakeSubstrateProtocolConfig {}

impl UpgradeInfo for FakeSubstrateProtocolConfig {
    type Info = &'static [u8];
    type InfoIter = Vec<&'static [u8]>;

    fn protocol_info(&self) -> Self::InfoIter {
        vec![b"/substrate/fir/5"]
    }
}

impl<C> InboundUpgrade<C> for FakeSubstrateProtocolConfig {
    type Output = Negotiated<C>;
    type Error = Void;
    type Future = Ready<Result<Negotiated<C>, Self::Error>>;

    fn upgrade_inbound(self, i: Negotiated<C>, _: Self::Info) -> Self::Future {
        future::ready(Ok(i))
    }
}

impl<C> OutboundUpgrade<C> for FakeSubstrateProtocolConfig {
    type Output = Negotiated<C>;
    type Error = Void;
    type Future = Ready<Result<Negotiated<C>, Self::Error>>;

    fn upgrade_outbound(self, i: Negotiated<C>, _: Self::Info) -> Self::Future {
        future::ready(Ok(i))
    }
}
